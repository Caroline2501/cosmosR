sub_df[(sub_df$weight > 0 & sub_df$stat < 0),"color"] <- "2"
sub_df[(sub_df$weight < 0 & sub_df$stat > 0),"color"] <- "2"
sub_df[(sub_df$weight < 0 & sub_df$stat < 0),"color"] <- "1"
sub_df[(percentile(sub_df$stat) < .95 & percentile(sub_df$stat) > .05),1] <- NA
print(paste("weights of ",names(weight_matrix)[j], sep = ""))
title <- paste("weights of ",names(weight_matrix)[j], sep = "")
scatterplot <- ggplot(sub_df, aes(x = weight, y = stat, color = color)) + geom_point() +
# scale_colour_manual(values = c("#15ff00","#ff0000","#c9c9c9")) + #green and red
scale_colour_manual(values = c("red","royalblue3","grey")) +
geom_label_repel(aes(label = ID)) +
ylim(minstat, maxstat) + theme_minimal() + theme(legend.position = "none") + geom_vline(xintercept = 0, linetype = 'dotted') + geom_hline(yintercept = 0, linetype = 'dotted') + labs(x = title, y = statName)
lay <- t(as.matrix(c(1,1,1,1,2)))
gg <- arrangeGrob(scatterplot, histo, nrow = 1, ncol = 2, layout_matrix = lay)
#grid.arrange(gg)
plot_list_pathways[[j-1]] <- gg
}
names(plot_list_pathways) <- names(weight_matrix[,-weightID])
plot_list_contrasts[[i-1]] <- plot_list_pathways
}
return(plot_list_contrasts)
}
full_targets <- as.data.frame(read_delim("~/Documents/Rebekka_CXCL4/src/full_targets.csv",
";", escape_double = FALSE, trim_ws = TRUE))
full_targets$`Mouse group` <- gsub(" ","_",full_targets$`Mouse group`)
full_targets$cellTypeorMarker <- gsub("CD41","MegaK",full_targets$cellTypeorMarker)
full_targets$cellTypeorMarker <- gsub("TdTomato_Gli1","Stromal",full_targets$cellTypeorMarker)
full_targets$`Mouse group` <- paste(full_targets$cellTypeorMarker,full_targets$`Mouse group`, sep = "_")
full_targets <- full_targets[order(full_targets$`Mouse group`),]
full_targets$replicates <- rep(c(1,2,3),8)
full_targets$sample <- paste(full_targets$`Mouse group`,full_targets$replicates, sep = "_")
targets <- full_targets[,c(12,10)]
names(targets) <- c("sample","condition")
count_file_list <- list.files("~/Documents/Rebekka_CXCL4/data/", full.names = T)
count_file_names <- gsub("[.]counts","",list.files("~/Documents/Rebekka_CXCL4/data/", full.names = F))
count_df_list <- list()
for(count_file in count_file_list)
{
count_df <- as.data.frame(read_delim(count_file,
"\t", escape_double = FALSE, col_names = FALSE,
trim_ws = TRUE))
count_df_list[[gsub("[.]counts","",count_file)]] <- count_df
}
i <- 1
for(count_df in count_df_list)
{
if(i == 1)
{
batches <- count_df
}
else
{
batches <- merge(batches,count_df, by = "X1", all = T)
}
i <- i+1
}
names(batches) <- c("ID", count_file_names)
batches <- batches[-c(1:5),]
batches <- batches[,c("ID",full_targets$`Sample Name`)]
names(batches) <- c("ID",targets$sample)
row.names(batches) <- batches$ID
batches <- batches[,-1]
SDs <- apply(batches,1,sd)
means <- apply(batches,1,mean)
#batches <- batches[means > 5 | SDs > 15,]
batches <- batches[means > 50,]
batches[batches == 0] <- 0.1
fit <- vsnMatrix(as.matrix(batches))
meanSdPlot(fit)
batches <- as.data.frame(predict(fit,as.matrix(batches)))
#targets$KO <- gsub("_EV","",targets$condition)
#targets$KO <- gsub("_TPO","",targets$KO)
comparisons_2 <- list("MegaK_EV" = c(1,-3), "MegaK_TPO" = c(2,-4), "Stromal_EV" = c(5,-7), "Stromal_TPO" = c(6,-8))
limmaRes_2 <- runLimma(batches,targets,comparisons_2)
ttop_list <- list()
for(i in 1:length(comparisons_2))
{
ttop_list[[i]] <- ttopFormatter(topTable(limmaRes_2[[1]], coef = i, number = length(batches[,1]), adjust.method = "fdr"))
}
names(ttop_list) <- names(comparisons_2)
View(ttop_list[[1]])
View(ttop_list[[2]])
# save(file = "~/Documents/Rebekka_CXCL4/results/ttop_list.RData", ttop_list)
##ONLY IF CHECK EFFECT OF MUTATION
for(i in 1:length(comparisons_2))
{
if( i == 1)
{
t_table <- ttop_list[[i]][,c(1,4)]
}
else
{
t_table <- merge(t_table,ttop_list[[i]][,c(1,4)], by = "ID")
}
}
names(t_table) <- c("ID",names(comparisons_2))
View(t_table)
View(t_table)
dorothea_regulon_mouse_v1 <- as.data.frame(read_csv("~/Documents/OMIC_tools/omicToolsTest/data/dorothea_regulon_mouse_v1.csv"))
dorothea_regulon_mouse_viper_AB <- df_to_viper_regulon(dorothea_regulon_mouse_v1[dorothea_regulon_mouse_v1$confidence %in% c("A","B"),c(3,1,4)])
TF_activity_viper <- runViper(ttop_list, regulon = dorothea_regulon_mouse_viper_AB)
makeViperResDf <- function(viperResList)
{
i <- 1
for (viperRes in viperResList)
{
viperScores <- viperRes
viperScores <- data.frame(viperScores)
print(viperScores)
viperScores$ID <- row.names(viperScores)
names(viperScores)[1] <- i
if (i == 1)
{
viperResDf <- viperScores
}
else
{
viperResDf <- merge(viperResDf, viperScores, by = "ID", all = T)
}
i <- i+1
}
if(i > 2)
{
names(viperResDf)[2:length(viperResDf[1,])] <- names(viperResList)
}
else
{
viperResDf <- viperResDf[,c(2,1)]
names(viperResDf) <- c("ID", names(viperResList))
}
return(viperResDf)
}
TF_activity_viper_df <- makeViperResDf(viperResList = TF_activity_viper)
row.names(TF_activity_viper_df) <- TF_activity_viper_df$ID
View(TF_activity_viper_df)
TF_activity_viper_df <- TF_activity_viper_df[order(abs(TF_activity_viper_df[,3]), decreasing = T),]
to_write <- as.data.frame(t(TF_activity_viper_df[,-1]))
to_write <- to_write[2,1:50]
View(to_write)
TF_activity_viper_df <- TF_activity_viper_df[order(abs(TF_activity_viper_df[,3]), decreasing = T),]
TF_activity_viper_df <- TF_activity_viper_df[order(abs(TF_activity_viper_df[,3]), decreasing = T),]
TF_activity_viper_df <- TF_activity_viper_df[(TF_activity_viper_df[,3]) > 1.7,]
to_write <- as.data.frame(t(TF_activity_viper_df[,-1]))
View(to_write)
TF_activity_viper_df <- makeViperResDf(viperResList = TF_activity_viper)
row.names(TF_activity_viper_df) <- TF_activity_viper_df$ID
View(TF_activity_viper_df)
TF_activity_viper_df <- TF_activity_viper_df[order(abs(TF_activity_viper_df[,3]), decreasing = T),]
View(TF_activity_viper_df)
to_write <- as.data.frame(t(TF_activity_viper_df[abs(TF_activity_viper_df[,3]) > 1.7,-1]))
to_write <- to_write[1,1:ifelse(length(to_write[1,]) > 50, 50, length(to_write[1,]))]
View(to_write)
TF_activity_viper_df <- TF_activity_viper_df[order(abs(TF_activity_viper_df[,2]), decreasing = T),]
to_write <- as.data.frame(t(TF_activity_viper_df[,-1]))
TF_activity_viper_df <- TF_activity_viper_df[order(abs(TF_activity_viper_df[,3]), decreasing = T),]
to_write <- as.data.frame(t(TF_activity_viper_df[abs(TF_activity_viper_df[,3]) > 1.7,-1]))
to_write <- to_write[2,1:ifelse(length(to_write[1,]) > 50, 50, length(to_write[1,]))]
write_tsv(to_write,"~/Dropbox/Rebekka_CXCL4/results/TF_megaK_TPO.tsv")
setwd("~/Dropbox/COSMOS/")
targets_1 <- as.data.frame(read_csv("data/metabolomic_targets.csv"))
library(readr)
library(limma)
library(vsn)
library(readxl)
targets_1 <- as.data.frame(read_csv("data/metabolomic_targets.csv"))
fit <- vsnMatrix(as.matrix(raw_metabolomic))
meanSdPlot(fit)
raw_metabolomic_vsn <- as.data.frame(vsn::predict(fit,as.matrix(raw_metabolomic)))
raw_metabolomic <- as.data.frame(read_csv("data/raw_metabolomic.csv"))
fit <- vsnMatrix(as.matrix(raw_metabolomic))
meanSdPlot(fit)
raw_metabolomic_vsn <- as.data.frame(vsn::predict(fit,as.matrix(raw_metabolomic)))
omicToolsTest::omicToolsTest::runLimma()
omicToolsTest::omicToolsTest::runLimma
omicToolsTest::runLimma
omicToolsTest::checkInputs
checkInputs <- function(measurments, targets)
{
if(class(measurments) != "data.frame")
{
error_message <- paste("The measurments argument should be a data.frame. It's currently a", paste(class(measurments), ".",sep = ""))
return(list(FALSE, error_message))
}
else
{
if(dim(measurments)[1] == 0)
{
error_message <- "The measurments dataframe doesn't seem to contain any measurments..."
return(list(FALSE, error_message))
}
else
{
if(dim(measurments)[2] == 0)
{
error_message <- "The measurments dataframe doesn't seem to contain any samples..."
return(list(FALSE, error_message))
}
else
{
if(class(as.matrix(measurments)[,1]) != "numeric")
{
return(list(FALSE, "The measurments dataframe should contain only numerical values (or NAs)."))
}
else
{
if(class(targets) != "data.frame")
{
error_message <- paste("The targets argument should be a data.frame. It's currently a", paste(class(targets), ".",sep = ""))
return(list(FALSE, error_message))
}
else
{
if(dim(targets)[2] < 2)
{
return(list(FALSE,"The targets dataframe should have at least two columns, sample names and conditions."))
}
else
{
if(dim(targets)[1] != dim(measurments)[2])
{
error_message <- paste("The targets dataframe should have as many samples (targets rows) as the measurements (measurments columns). Currently, the targets dataframe has", paste(dim(targets)[1], "samples and the measurements have", paste(dim(measurments)[2],"samples.")))
return(list(FALSE, error_message))
}
else
{
}
}
}
}
}
}
}
return(list(TRUE, "All seems to be in order..."))
}
runLimma <- function(measurements, targets, comparisons = NULL, pool = NULL, regress_out = NULL)
{
input_check <- checkInputs(measurements, targets)
if (input_check[[1]]) #input has correct format
{
if (!is.null(comparisons))
{
if (!is.null(regress_out))
{
for (regressor in regress_out)
{
measurements <- removeBatchEffect(measurements, targets[,regressor])
}
}
cont.matrix <- makeContrastsAlt(targets, comparisons)
if (!is.null(pool))
{
cont.matrix <- poolContrasts(cont.matrix, pool)
}
cont.matrix <- as.data.frame(cont.matrix)
row.names(cont.matrix) <- unique(targets$condition)
cont.matrix <- as.matrix(cont.matrix)
fcond <- factor(targets$condition, levels = unique(targets$condition))
design <- model.matrix(~0+fcond)
design <- as.data.frame(design)
names(design) <- unique(targets$condition)
design <- as.matrix(design)
print(cont.matrix)
fit <- lmFit(measurements, design)
fit2 <- contrasts.fit(fit, cont.matrix)
fit2 <- eBayes(fit2)
return(list(fit2, cont.matrix, fit))
}
}
else
{
print(input_check[[2]])
return(input_check[[1]])
}
}
limmaRes <- runLimma(raw_metabolomic_vsn, targets_1, comparisons = list(c(1,-2)))
omicToolsTest::makeContrastsAlt
makeContrastsAlt <- function(targets, comparisons)
{
cont.matrix <- matrix(0,nrow = length(unique(targets$condition)), ncol = length(comparisons))
i <- 1
for (comparison in comparisons)
{
for (j in 1:length(comparison))
{
cont.matrix[abs(comparison[j]),i] <- cont.matrix[abs(comparison[j]),i]+(comparison[j]/abs(comparison[j]))
}
i <- i + 1
}
return(cont.matrix)
}
checkInputs <- function(measurments, targets)
{
if(class(measurments) != "data.frame")
{
error_message <- paste("The measurments argument should be a data.frame. It's currently a", paste(class(measurments), ".",sep = ""))
return(list(FALSE, error_message))
}
else
{
if(dim(measurments)[1] == 0)
{
error_message <- "The measurments dataframe doesn't seem to contain any measurments..."
return(list(FALSE, error_message))
}
else
{
if(dim(measurments)[2] == 0)
{
error_message <- "The measurments dataframe doesn't seem to contain any samples..."
return(list(FALSE, error_message))
}
else
{
if(class(as.matrix(measurments)[,1]) != "numeric")
{
return(list(FALSE, "The measurments dataframe should contain only numerical values (or NAs)."))
}
else
{
if(class(targets) != "data.frame")
{
error_message <- paste("The targets argument should be a data.frame. It's currently a", paste(class(targets), ".",sep = ""))
return(list(FALSE, error_message))
}
else
{
if(dim(targets)[2] < 2)
{
return(list(FALSE,"The targets dataframe should have at least two columns, sample names and conditions."))
}
else
{
if(dim(targets)[1] != dim(measurments)[2])
{
error_message <- paste("The targets dataframe should have as many samples (targets rows) as the measurements (measurments columns). Currently, the targets dataframe has", paste(dim(targets)[1], "samples and the measurements have", paste(dim(measurments)[2],"samples.")))
return(list(FALSE, error_message))
}
else
{
}
}
}
}
}
}
}
return(list(TRUE, "All seems to be in order..."))
}
runLimma <- function(measurements, targets, comparisons = NULL, pool = NULL, regress_out = NULL)
{
input_check <- checkInputs(measurements, targets)
if (input_check[[1]]) #input has correct format
{
if (!is.null(comparisons))
{
if (!is.null(regress_out))
{
for (regressor in regress_out)
{
measurements <- removeBatchEffect(measurements, targets[,regressor])
}
}
cont.matrix <- makeContrastsAlt(targets, comparisons)
if (!is.null(pool))
{
cont.matrix <- poolContrasts(cont.matrix, pool)
}
cont.matrix <- as.data.frame(cont.matrix)
row.names(cont.matrix) <- unique(targets$condition)
cont.matrix <- as.matrix(cont.matrix)
fcond <- factor(targets$condition, levels = unique(targets$condition))
design <- model.matrix(~0+fcond)
design <- as.data.frame(design)
names(design) <- unique(targets$condition)
design <- as.matrix(design)
print(cont.matrix)
fit <- lmFit(measurements, design)
fit2 <- contrasts.fit(fit, cont.matrix)
fit2 <- eBayes(fit2)
return(list(fit2, cont.matrix, fit))
}
}
else
{
print(input_check[[2]])
return(input_check[[1]])
}
}
limmaRes <- runLimma(raw_metabolomic_vsn, targets_1, comparisons = list(c(1,-2)))
ttop_tumour_vs_healthy <- ttopFormatter(topTable(limmaRes[[1]], coef = 1, number = length(raw_metabolomic_vsn[,1]), adjust.method = "fdr"))
omicToolsTest::ttopFormatter
makeContrastsAlt <- function(targets, comparisons)
{
cont.matrix <- matrix(0,nrow = length(unique(targets$condition)), ncol = length(comparisons))
i <- 1
for (comparison in comparisons)
{
for (j in 1:length(comparison))
{
cont.matrix[abs(comparison[j]),i] <- cont.matrix[abs(comparison[j]),i]+(comparison[j]/abs(comparison[j]))
}
i <- i + 1
}
return(cont.matrix)
}
checkInputs <- function(measurments, targets)
{
if(class(measurments) != "data.frame")
{
error_message <- paste("The measurments argument should be a data.frame. It's currently a", paste(class(measurments), ".",sep = ""))
return(list(FALSE, error_message))
}
else
{
if(dim(measurments)[1] == 0)
{
error_message <- "The measurments dataframe doesn't seem to contain any measurments..."
return(list(FALSE, error_message))
}
else
{
if(dim(measurments)[2] == 0)
{
error_message <- "The measurments dataframe doesn't seem to contain any samples..."
return(list(FALSE, error_message))
}
else
{
if(class(as.matrix(measurments)[,1]) != "numeric")
{
return(list(FALSE, "The measurments dataframe should contain only numerical values (or NAs)."))
}
else
{
if(class(targets) != "data.frame")
{
error_message <- paste("The targets argument should be a data.frame. It's currently a", paste(class(targets), ".",sep = ""))
return(list(FALSE, error_message))
}
else
{
if(dim(targets)[2] < 2)
{
return(list(FALSE,"The targets dataframe should have at least two columns, sample names and conditions."))
}
else
{
if(dim(targets)[1] != dim(measurments)[2])
{
error_message <- paste("The targets dataframe should have as many samples (targets rows) as the measurements (measurments columns). Currently, the targets dataframe has", paste(dim(targets)[1], "samples and the measurements have", paste(dim(measurments)[2],"samples.")))
return(list(FALSE, error_message))
}
else
{
}
}
}
}
}
}
}
return(list(TRUE, "All seems to be in order..."))
}
runLimma <- function(measurements, targets, comparisons = NULL, pool = NULL, regress_out = NULL)
{
input_check <- checkInputs(measurements, targets)
if (input_check[[1]]) #input has correct format
{
if (!is.null(comparisons))
{
if (!is.null(regress_out))
{
for (regressor in regress_out)
{
measurements <- removeBatchEffect(measurements, targets[,regressor])
}
}
cont.matrix <- makeContrastsAlt(targets, comparisons)
if (!is.null(pool))
{
cont.matrix <- poolContrasts(cont.matrix, pool)
}
cont.matrix <- as.data.frame(cont.matrix)
row.names(cont.matrix) <- unique(targets$condition)
cont.matrix <- as.matrix(cont.matrix)
fcond <- factor(targets$condition, levels = unique(targets$condition))
design <- model.matrix(~0+fcond)
design <- as.data.frame(design)
names(design) <- unique(targets$condition)
design <- as.matrix(design)
print(cont.matrix)
fit <- lmFit(measurements, design)
fit2 <- contrasts.fit(fit, cont.matrix)
fit2 <- eBayes(fit2)
return(list(fit2, cont.matrix, fit))
}
}
else
{
print(input_check[[2]])
return(input_check[[1]])
}
}
ttopFormatter <- function(ttop)
{
ttop$ID <- row.names(ttop)
ttop <- ttop[,c(7,1,2,3,4,5,6)]
ttop <- ttop[complete.cases(ttop),]
return(ttop)
}
ttop_tumour_vs_healthy <- ttopFormatter(topTable(limmaRes[[1]], coef = 1, number = length(raw_metabolomic_vsn[,1]), adjust.method = "fdr"))
write_csv(ttop_tumour_vs_healthy, "results/metabolomic/ttop_tumour_vs_healthy.csv")
source("scripts/limma_functions.R")
